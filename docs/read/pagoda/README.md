# Pagoda

> [**Pagoda: A Hybrid Approach to Enable Efficient Real-Time Provenance Based Intrusion Detection in Big Data Environments**](https://ieeexplore.ieee.org/abstract/document/8450016)
> 

与ProvDetector类似，它利用事件频率数据库为单个边缘分配稀有性分数。如果路径中的边不是频率数据库的一部分，则为其分配1分；否则，边缘的得分为零。

## **数据预处理**

**输入**：收集到的溯源记录。

**步骤**：

1. **剪枝**：过滤掉噪声数据，如临时文件、管道文件等，只保留与入侵检测相关的关键数据。
2. **标准化**：将对象名称（如文件路径、进程名称）标准化，以便后续处理。

## **依赖关系提取**

**输入**：剪枝后的溯源记录。

**输出**：依赖关系列表。

**步骤**：

1. **提取依赖关系**：从溯源记录中提取对象之间的依赖关系。例如，如果文件 `f` 被进程 `p` 读取，则提取依赖关系 `p → f`。
2. **统计依赖关系频率**：统计每个依赖关系在多次运行中出现的频率。

## **规则数据库构建**

**输入**：依赖关系列表及其出现频率。

**输出**：规则数据库（RuleDB）。

**步骤**：

1. **设置阈值**：设定一个阈值 `T1`，用于判断依赖关系是否频繁出现。
2. **筛选频繁依赖关系**：将出现频率高于 `T1` 的依赖关系加入规则数据库。例如，如果依赖关系 `p → f` 在多次运行中出现的频率高于 `T1`，则将其加入 RuleDB。
3. **存储依赖关系**：将频繁出现的依赖关系存储在规则数据库中。每个依赖关系表示为一个元组 `(child, parent)`，其中 `child` 是子对象，`parent` 是父对象。

## **去重和优化**

**输入**：规则数据库。

**输出**：优化后的规则数据库。

**步骤**：

1. **去重**：使用字典编码技术去除规则数据库中的重复字符串。例如，如果多个依赖关系中包含相同的文件路径或进程名称，可以将其编码为一个整数，以减少存储空间。
2. **优化存储**：将规则数据库存储在内存数据库（如Redis）中，以提高查询效率。

## **以上步骤的示例**

假设我们有一个正常应用程序 `editor`，其多次运行生成的溯源记录如下：

- 运行1：`p1 → f1`, `p1 → f2`, `p1 → f3`
- 运行2：`p1 → f1`, `p1 → f2`, `p1 → f4`
- 运行3：`p1 → f1`, `p1 → f2`, `p1 → f5`
1. **提取依赖关系**：
    - `p1 → f1` 出现 3 次
    - `p1 → f2` 出现 3 次
    - `p1 → f3` 出现 1 次
    - `p1 → f4` 出现 1 次
    - `p1 → f5` 出现 1 次
2. **设置阈值**：假设阈值 `T1 = 2`。
3. **筛选频繁依赖关系**：
    - `p1 → f1` 出现 3 次，加入 RuleDB。
    - `p1 → f2` 出现 3 次，加入 RuleDB。
    - `p1 → f3` 出现 1 次，不加入 RuleDB。
    - `p1 → f4` 出现 1 次，不加入 RuleDB。
    - `p1 → f5` 出现 1 次，不加入 RuleDB。
4. **存储依赖关系**：
    - RuleDB = `{(p1, f1), (p1, f2)}`
5. **去重和优化**：
    - 使用字典编码技术将 `p1`、`f1` 和 `f2` 编码为整数，例如 `p1 = 1`, `f1 = 2`, `f2 = 3`。
    - 优化后的 RuleDB = `{(1, 2), (1, 3)}`

### **检测过程**

**输入**：待检测的溯源图。

**输出**：检测结果（是否为入侵行为）。

**步骤**：

1. **路径异常度计算**：
    - 对每个路径，计算路径中每个边的异常度。
    - 异常度计算公式：如果边在中存在，则异常度为0；否则为1。
    - 路径异常度计算公式：
        
        
        其中，*L* 是路径的长度。
        
        $$
        P=\sum_{i=1}^{L}anomaly\space degree \space of \space each\space  edge
        $$
        
2. **路径权重计算**：
    - 计算每个路径的权重： $W=\frac{L_i}{\sum_{i-1}^{n}L_i}$
    其中，*Li* 是路径 *i* 的长度，*n* 是路径的总数。
3. **图异常度计算**：
    - 计算整个溯源图的异常度： $Q=\frac{\sum_{i=1}^{n}(P_{i} \centerdot L_i)}{\sum_{i=1}^{n}L_i}$
    其中，*Pi* 是路径 *i* 的异常度， $L_i$ 是路径 *i* 的长度。
4. **检测阈值判断**：
    - 如果路径异常度 *P* 超过路径阈值，则立即触发报警。
    - 如果路径异常度未超过路径阈值，则继续计算整个溯源图的异常度 *Q*。
    - 如果图异常度 *Q* 超过图阈值，则触发报警。